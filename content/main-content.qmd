# Introduction

This comprehensive reference guide provides essential pension mathematics formulas, concepts, and implementation examples designed for integration with Claude Code and actuarial simulation models. The guide covers traditional actuarial methods [@winklevoss_1993], modern financial economics approaches [@aaa_soa_2006], and practical implementation in R and Python environments.

## How to Use This Guide

- **Formulas**: All mathematical expressions in both standard and code-ready format
- **Implementation**: R code examples throughout
- **Validation**: Built-in consistency checks

# Basic Actuarial Functions

## Interest Functions

The present value of $1 due in n years [@bowers_1997]:
```
v^n = 1 / (1 + i)^n
```
Where:

- `v` = discount factor = 1/(1+i)
- `i` = interest rate
- `n` = number of years

```{r}
#| label: present-value-function
# Present value function in R
present_value <- function(future_value, interest_rate, years) {
  return(future_value / (1 + interest_rate)^years)
}

# Example calculation
pv_example <- present_value(1000, 0.05, 10)
cat("Present value of $1000 due in 10 years at 5%:", pv_example)
```

## Survival Functions
Probability of survival from age x to age x+t:
```
t_p_x = probability of surviving t years from age x
```

## Salary Functions
Future salary projection:
```
S_x = S_y * (SS_x / SS_y) * [(1 + I)(1 + P)]^(x-y)
```
Where:

- `S_x` = salary at age x
- `S_y` = entry age salary
- `SS_x` = merit salary scale at age x
- `I` = inflation rate
- `P` = productivity rate

```{r}
#| label: salary-projection
# Salary projection function
project_salary <- function(
  entry_salary,
  entry_age,
  current_age,
  merit_scale_current,
  merit_scale_entry,
  inflation_rate,
  productivity_rate
) {
  years_elapsed <- current_age - entry_age
  merit_factor <- merit_scale_current / merit_scale_entry
  economic_factor <- (1 + inflation_rate + productivity_rate)^years_elapsed

  return(entry_salary * merit_factor * economic_factor)
}

# Example
salary_example <- project_salary(50000, 25, 35, 1.2, 1.0, 0.03, 0.01)
cat("Projected salary:", salary_example)
```

## Annuity Functions
Present value of life annuity:
```
a_x = Σ(t=0 to ∞) t_p_x * v^t
```

# Pension Liability Calculations

## Present Value of Future Benefits (PVFB)
The actuarial present value of all expected future benefit payments:
```
PVFB = Σ expected_future_benefits * discount_factors * survival_probabilities
```

## Three Key Liability Measures

### 1. Market Liability
Market value using risk-adjusted discount rates matching traded securities with similar cash flow patterns.

### 2. Solvency Liability  
Present value using risk-free rates (e.g., Treasury bonds):
```
Solvency_Liability = Σ benefit_payments * treasury_discount_factors
```

### 3. Budget Liability (Actuarial Liability - AL)
Traditional actuarial accrued liability for funding purposes [@aaa_2004]:
```
AL = portion of PVFB attributed to past service
```

## Benefit Obligation Measures

### Projected Benefit Obligation (PBO)
Present value of benefits earned to date based on projected future salaries:
```
PBO_end = PBO_begin + Service_Cost + Interest_Cost ± Actuarial_Gains_Losses + Plan_Amendments - Benefits_Paid
```

```{r}
#| label: pbo-calculation
# PBO calculation function
calculate_pbo_end <- function(
  pbo_begin,
  service_cost,
  interest_cost,
  actuarial_gains_losses,
  plan_amendments,
  benefits_paid
) {
  pbo_end <- pbo_begin +
    service_cost +
    interest_cost +
    actuarial_gains_losses +
    plan_amendments -
    benefits_paid
  return(pbo_end)
}
```

### Service Cost
Present value of benefits earned in current year:
```
Service_Cost = present_value_of_current_year_benefit_accrual
```

### Interest Cost
Growth in obligation due to passage of time:
```
Interest_Cost = PBO_beginning * discount_rate
```

```{r}
#| label: interest-cost
# Interest cost calculation
calculate_interest_cost <- function(pbo_beginning, discount_rate) {
  return(pbo_beginning * discount_rate)
}
```

# Cost Methods

## Unit Credit Method
Allocates costs based on benefits accrued each year under the plan formula.

**Normal Cost:**
```
NC = present_value_of_benefit_accrued_in_current_year
```

**Actuarial Liability:**
```
AL = present_value_of_benefits_accrued_to_date
```

## Projected Unit Credit Method
Like Unit Credit but incorporates expected future salary increases.

**For final average pay plans:**
```
Projected_Annual_Benefit = k * (years_of_service) * (1/n) * Σ(final_n_years_salary)
```
Where:

- `k` = benefit multiplier (e.g., 0.015 for 1.5%)
- `n` = averaging period

```{r}
#| label: benefit-calculation
# Final average pay benefit calculation
calculate_final_average_benefit <- function(
  years_of_service,
  final_salaries,
  benefit_multiplier
) {
  average_salary <- mean(final_salaries)
  return(years_of_service * average_salary * benefit_multiplier)
}

# Example
final_5_salaries <- c(80000, 82000, 84000, 86000, 88000)
benefit_example <- calculate_final_average_benefit(30, final_5_salaries, 0.015)
cat("Annual benefit:", benefit_example)
```

# Funding Principles

## Basic Funding Equation
From fundamental actuarial principles [@aaa_2004]:
```
Required_Contribution = Normal_Cost + Amortization_of_Unfunded_Liability
```

## Unfunded Actuarial Liability (UAL)
```
UAL = Actuarial_Liability - Actuarial_Value_of_Assets
```

## Funded Ratio
```
Funded_Ratio = Market_Value_of_Assets / Actuarial_Liability
```

```{r}
#| label: funding-calculations
# Funding calculations
calculate_ual <- function(actuarial_liability, asset_value) {
  return(actuarial_liability - asset_value)
}

calculate_funded_ratio <- function(asset_value, actuarial_liability) {
  return(asset_value / actuarial_liability)
}

calculate_required_contribution <- function(
  normal_cost,
  ual,
  amortization_period,
  discount_rate
) {
  if (ual <= 0) {
    return(normal_cost)
  }

  # Calculate amortization payment
  if (discount_rate == 0) {
    amortization_payment <- ual / amortization_period
  } else {
    amortization_factor <- discount_rate /
      (1 - (1 + discount_rate)^(-amortization_period))
    amortization_payment <- ual * amortization_factor
  }

  return(normal_cost + amortization_payment)
}

# Example calculations
example_ual <- calculate_ual(1000000, 800000)
example_funded_ratio <- calculate_funded_ratio(800000, 1000000)
example_contribution <- calculate_required_contribution(
  50000,
  example_ual,
  15,
  0.07
)

cat("UAL:", example_ual, "\n")
cat("Funded Ratio:", example_funded_ratio, "\n")
cat("Required Contribution:", example_contribution, "\n")
```

## Amortization Payments
```
Annual_Amortization = UAL * [i / (1 - (1+i)^(-n))]
```
Where n is the amortization period.

# Actuarial Assumptions

## Economic Assumptions

### Discount Rate Selection
- **Funding:** Expected return on plan assets
- **Accounting:** High-quality corporate bond yields
- **Market Valuation:** Risk-adjusted rates matching benefit cash flows

### Salary Scale
```
Salary_Growth_Rate = Inflation + Productivity + Merit_Increases
```

## Demographic Assumptions

### Mortality Rates
```
q_x = probability of death between age x and x+1
p_x = 1 - q_x = probability of survival
```

### Withdrawal/Termination Rates
```
w_x = probability of terminating employment at age x
```

### Retirement Rates
```
r_x = probability of retiring at age x
```

# Mortality Table Implementation

## Standard Mortality Tables

Mortality tables are fundamental to pension calculations. This section provides practical implementation of standard actuarial tables [@soa_mortality2014].

### Basic Mortality Table Structure

```{r}
#| label: mortality-table-setup
# Create a simplified mortality table structure
# In practice, you would load this from standard tables like RP-2014
create_sample_mortality_table <- function() {
  ages <- 20:110

  # Simplified Gompertz-Makeham mortality rates
  # q_x = A + B * C^x where A = 0.0001, B = 0.00005, C = 1.08
  q_x <- pmin(0.0001 + 0.00005 * 1.08^ages, 0.95)

  mortality_table <- data.frame(
    age = ages,
    q_x = q_x,
    p_x = 1 - q_x
  )

  # Calculate survival probabilities from age 20
  mortality_table$l_x <- numeric(length(ages))
  mortality_table$l_x[1] <- 100000 # Radix of 100,000

  for (i in 2:length(ages)) {
    mortality_table$l_x[i] <- mortality_table$l_x[i - 1] *
      mortality_table$p_x[i - 1]
  }

  return(mortality_table)
}

# Create sample table
mortality_table <- create_sample_mortality_table()

# Display first few rows
head(mortality_table, 10)
```

### Survival Probability Functions

```{r}
#| label: survival-functions
# Function to calculate t-year survival probability from age x
calculate_survival_probability <- function(mortality_table, age_x, years_t) {
  if (
    age_x < min(mortality_table$age) ||
      age_x + years_t > max(mortality_table$age)
  ) {
    return(0)
  }

  start_idx <- which(mortality_table$age == age_x)
  end_idx <- which(mortality_table$age == age_x + years_t)

  if (length(start_idx) == 0 || length(end_idx) == 0) {
    return(0)
  }

  return(mortality_table$l_x[end_idx] / mortality_table$l_x[start_idx])
}

# Function to calculate life annuity values (immediate or deferred)
calculate_life_annuity <- function(
  mortality_table,
  start_age,
  payment_start_age = NULL,
  discount_rate,
  annual_payment = 1
) {
  # If no payment start age specified, annuity starts immediately
  if (is.null(payment_start_age)) {
    payment_start_age <- start_age
  }

  # Calculate probability of survival to payment start (1 if immediate)
  if (payment_start_age > start_age) {
    survival_to_payment <- calculate_survival_probability(
      mortality_table,
      start_age,
      payment_start_age - start_age
    )
  } else {
    survival_to_payment <- 1
  }

  # Calculate present value of annuity starting at payment_start_age
  annuity_value <- 0
  current_age <- payment_start_age

  while (
    current_age <= max(mortality_table$age) &&
      current_age < payment_start_age + 50
  ) {
    # Limit to reasonable age

    # Survival probability from payment start to current age
    if (current_age == payment_start_age) {
      surv_from_payment_start <- 1
    } else {
      surv_from_payment_start <- calculate_survival_probability(
        mortality_table,
        payment_start_age,
        current_age - payment_start_age
      )
    }

    if (surv_from_payment_start < 0.001) {
      break
    } # Negligible probability

    # Present value of payment at current age (from original start age)
    years_from_start <- current_age - start_age
    pv_payment <- annual_payment *
      surv_from_payment_start *
      (1 + discount_rate)^(-years_from_start)

    annuity_value <- annuity_value + pv_payment
    current_age <- current_age + 1
  }

  return(annuity_value * survival_to_payment)
}

# Wrapper function for deferred annuity (backwards compatibility)
calculate_deferred_annuity <- function(
  mortality_table,
  start_age,
  payment_age,
  discount_rate,
  annual_payment = 1
) {
  return(calculate_life_annuity(
    mortality_table,
    start_age,
    payment_age,
    discount_rate,
    annual_payment
  ))
}

# Examples
survival_30_to_65 <- calculate_survival_probability(mortality_table, 30, 35)
cat("Probability of surviving from age 30 to 65:", survival_30_to_65, "\n")

annuity_30_defer_to_65 <- calculate_life_annuity(mortality_table, 30, 65, 0.07)
cat(
  "Present value of $1 annuity deferred from age 30 to 65:",
  annuity_30_defer_to_65,
  "\n"
)
```

### Multiple Decrement Tables

```{r}
#| label: multiple-decrements
# Create a service table with multiple decrements
create_service_table <- function(
  mortality_table,
  withdrawal_rates = NULL,
  disability_rates = NULL
) {
  ages <- mortality_table$age
  n_ages <- length(ages)

  # Default withdrawal rates (higher at younger ages)
  if (is.null(withdrawal_rates)) {
    withdrawal_rates <- pmax(0.15 * exp(-0.1 * (ages - 20)), 0.01)
    withdrawal_rates[ages >= 65] <- 0 # No withdrawal after retirement
  }

  # Default disability rates (increasing with age)
  if (is.null(disability_rates)) {
    disability_rates <- pmin(0.001 * 1.05^(ages - 20), 0.02)
    disability_rates[ages >= 65] <- 0 # No disability after retirement
  }

  service_table <- data.frame(
    age = ages,
    q_x_death = mortality_table$q_x,
    q_x_withdrawal = withdrawal_rates,
    q_x_disability = disability_rates
  )

  # Calculate composite survival probability
  service_table$q_x_total <- with(
    service_table,
    q_x_death + q_x_withdrawal + q_x_disability
  )
  service_table$q_x_total <- pmin(service_table$q_x_total, 0.95) # Cap at 95%
  service_table$p_x_active <- 1 - service_table$q_x_total

  # Calculate active life table
  service_table$l_x_active <- numeric(n_ages)
  service_table$l_x_active[1] <- 100000

  for (i in 2:n_ages) {
    service_table$l_x_active[i] <- service_table$l_x_active[i - 1] *
      service_table$p_x_active[i - 1]
  }

  return(service_table)
}

# Create service table
service_table <- create_service_table(mortality_table)

# Display sample
head(service_table[service_table$age %in% 25:35, ], 10)
```

# Financial Economics Approach

## Augmented Balance Sheet
Following the framework established by the financial economics literature [@aaa_soa_2006], pension plans are viewed as corporate assets and liabilities:

**Corporate Balance Sheet Integration:**
```
Total_Corporate_Assets = Operating_Assets + Net_Pension_Assets
Total_Corporate_Liabilities = Operating_Liabilities + Net_Pension_Liabilities
```

**Tax Adjustments:**
```
Net_Pension_Assets = Gross_Pension_Assets * (1 - Corporate_Tax_Rate)
Net_Pension_Liabilities = Gross_Pension_Liabilities * (1 - Corporate_Tax_Rate)
```

## Market-Based Liability Valuation
```
Market_Liability = Σ benefit_cash_flows * market_discount_factors
```

Where market discount factors reflect the credit risk and timing of benefit payments.

# Implementation Examples

## Simple Pension Plan Class

```{r}
#| label: pension-plan-class
# Simple pension plan simulation class using R6
library(R6)

PensionPlan <- R6Class(
  "PensionPlan",
  public = list(
    participants = NULL,
    assets = NULL,
    assumptions = NULL,

    initialize = function(initial_assets = 0, assumptions = list()) {
      self$assets <- initial_assets
      self$assumptions <- assumptions
      self$participants <- data.frame()
    },

    add_participant = function(id, age, salary, service) {
      new_participant <- data.frame(
        id = id,
        age = age,
        salary = salary,
        service = service
      )
      self$participants <- rbind(self$participants, new_participant)
    },

    calculate_actuarial_liability = function(discount_rate = 0.07) {
      if (nrow(self$participants) == 0) {
        return(0)
      }

      total_liability <- 0
      for (i in 1:nrow(self$participants)) {
        participant <- self$participants[i, ]

        # Simple benefit calculation (1.5% of final salary per year of service)
        projected_benefit <- participant$salary *
          1.02^(65 - participant$age) *
          participant$service *
          0.015

        # Present value (simplified - assumes retirement at 65)
        years_to_retirement <- max(0, 65 - participant$age)
        pv_benefit <- projected_benefit /
          (1 + discount_rate)^years_to_retirement

        total_liability <- total_liability + pv_benefit
      }

      return(total_liability)
    },

    annual_valuation = function() {
      # Age participants
      self$participants$age <- self$participants$age + 1
      self$participants$service <- self$participants$service + 1

      # Calculate liabilities
      actuarial_liability <- self$calculate_actuarial_liability()

      # Calculate funded ratio
      funded_ratio <- if (actuarial_liability > 0) {
        self$assets / actuarial_liability
      } else {
        Inf
      }

      return(list(
        assets = self$assets,
        liabilities = actuarial_liability,
        funded_ratio = funded_ratio,
        participants = nrow(self$participants)
      ))
    }
  )
)

# Example usage
plan <- PensionPlan$new(initial_assets = 1000000)
plan$add_participant(1, 35, 50000, 10)
plan$add_participant(2, 45, 75000, 20)
plan$add_participant(3, 25, 40000, 5)

valuation_results <- plan$annual_valuation()
print(valuation_results)
```

# Key Relationships and Validation Checks

## Fundamental Equation
```
PVFB = Actuarial_Liability + Normal_Cost + PVFNC
```
Where PVFNC = Present Value of Future Normal Costs

## Consistency Checks
1. **Asset-Liability Reconciliation:**
   ```
   Funded_Status = Assets - Liabilities
   ```

2. **Cost Method Validation:**
   ```
   Sum of all Normal Costs (present value) + Initial AL = PVFB
   ```

3. **Experience Gains/Losses:**
   ```
   Actuarial_Gain = Expected_Liability - Actual_Liability
   ```

# Validation Examples

## Fundamental Equation Validation

This section demonstrates the fundamental actuarial equation: **PVFB = AL + NC + PVFNC** using numerical examples.

### Single Participant Validation

```{r}
#| label: single-participant-validation
# Validate fundamental equation for a single participant
validate_single_participant <- function(
  entry_age,
  current_age,
  retirement_age,
  entry_salary,
  benefit_rate,
  discount_rate,
  salary_growth_rate,
  mortality_table,
  service_table
) {
  current_service <- current_age - entry_age
  total_service_at_retirement <- retirement_age - entry_age

  # Project salary to retirement
  salary_at_retirement <- entry_salary *
    (1 + salary_growth_rate)^(retirement_age - entry_age)

  # Calculate projected annual benefit at retirement
  projected_annual_benefit <- total_service_at_retirement *
    salary_at_retirement *
    benefit_rate

  # 1. Calculate PVFB (Present Value of Future Benefits)
  survival_to_retirement <- calculate_survival_probability(
    service_table,
    current_age,
    retirement_age - current_age
  )
  # Calculate immediate life annuity at retirement age
  annuity_at_retirement <- calculate_life_annuity(
    mortality_table,
    retirement_age,
    retirement_age,
    discount_rate
  )

  pvfb <- projected_annual_benefit *
    survival_to_retirement *
    annuity_at_retirement *
    (1 + discount_rate)^(-(retirement_age - current_age))

  # 2. Calculate Actuarial Liability (AL) - Unit Credit Method
  # Benefit accrued to date
  current_salary <- entry_salary *
    (1 + salary_growth_rate)^(current_age - entry_age)
  accrued_annual_benefit <- current_service *
    salary_at_retirement *
    benefit_rate

  al <- accrued_annual_benefit *
    survival_to_retirement *
    annuity_at_retirement *
    (1 + discount_rate)^(-(retirement_age - current_age))

  # 3. Calculate Normal Cost (NC)
  # Benefit accruing in current year
  annual_benefit_accrual <- 1 * salary_at_retirement * benefit_rate

  nc <- annual_benefit_accrual *
    survival_to_retirement *
    annuity_at_retirement *
    (1 + discount_rate)^(-(retirement_age - current_age))

  # 4. Calculate PVFNC (Present Value of Future Normal Costs)
  remaining_years <- retirement_age - current_age - 1
  if (remaining_years > 0) {
    pvfnc <- nc * remaining_years # Simplified - assumes level normal costs
  } else {
    pvfnc <- 0
  }

  # Validation
  fundamental_equation_lhs <- pvfb
  fundamental_equation_rhs <- al + nc + pvfnc
  difference <- abs(fundamental_equation_lhs - fundamental_equation_rhs)

  results <- list(
    participant = paste(
      "Age",
      current_age,
      "with",
      current_service,
      "years service"
    ),
    pvfb = pvfb,
    al = al,
    nc = nc,
    pvfnc = pvfnc,
    equation_lhs = fundamental_equation_lhs,
    equation_rhs = fundamental_equation_rhs,
    difference = difference,
    relative_error = difference / pvfb,
    validates = difference < 0.01 * pvfb # Within 1%
  )

  return(results)
}

# Run validation for a sample participant
validation_result <- validate_single_participant(
  entry_age = 25,
  current_age = 35,
  retirement_age = 65,
  entry_salary = 50000,
  benefit_rate = 0.015, # 1.5% per year
  discount_rate = 0.07,
  salary_growth_rate = 0.04,
  mortality_table = mortality_table,
  service_table = service_table
)

# Display results
cat("=== FUNDAMENTAL EQUATION VALIDATION ===\n")
cat("Participant:", validation_result$participant, "\n\n")
cat("PVFB (Left side):", round(validation_result$pvfb, 2), "\n")
cat(
  "AL + NC + PVFNC (Right side):",
  round(validation_result$equation_rhs, 2),
  "\n"
)
cat("  - AL:", round(validation_result$al, 2), "\n")
cat("  - NC:", round(validation_result$nc, 2), "\n")
cat("  - PVFNC:", round(validation_result$pvfnc, 2), "\n\n")
cat("Difference:", round(validation_result$difference, 2), "\n")
cat("Relative Error:", round(validation_result$relative_error * 100, 3), "%\n")
cat(
  "Validation Result:",
  ifelse(validation_result$validates, "PASS", "FAIL"),
  "\n"
)
```

# Conclusion

This reference guide provides the essential mathematical foundation for building pension simulation models. All formulas are implementable in R or Python environments and designed for integration with Claude Code for enhanced actuarial modeling capabilities.

The guide synthesizes established actuarial principles [@winklevoss_1993; @bowers_1997; @anderson2006] with modern financial economics approaches [@aaa_soa_2006] to provide a comprehensive computational framework for pension mathematics.

Key contributions include:

- **Comprehensive formula library** with both mathematical and computational representations
- **Practical mortality table implementation** with multiple decrement modeling
- **Validation framework** demonstrating fundamental actuarial relationships
- **Working code examples** in R suitable for pension simulation projects
- **Integration guidance** for Claude Code and modern development workflows

The guide will be updated as new concepts and methods are incorporated into the pension simulation framework.

```{=typst}
#pagebreak()
```

```{=typst}
#bibliography("references.bib", full: true, style: "harvard-cite-them-right")
```